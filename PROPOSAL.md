The project I want to do is create a Cinder visualization application for the A* pathfinding 
algorithm, the Bidirectional Breadth-First Search, and the Breadth-First Search. The program would 
allow users to drag and create a terrain for the algorithms to run using something similar to the 
Naive Bayes structure (users click on the mouse to draw a black square). Then, there would be a 
finish and start block which the algorithm would use to find the shortest path. The users would be 
allowed to select which algorithm they want to run. After this, the algorithm would run, highlighting 
squares that it would use as a red color. Some stretch goals I could implement would be allowing 
the users to place down a starting place and ending place. Moreover, I could implement other 
algorithms for pathfinding/searching. I could also compare how fast each pathfinding/search algorithm
 is at finding the shortest path for the same terrain. 

I have some basic background knowledge on general algorithms, but I felt that I wanted to understand 
pathfinding/search algorithms at a deeper level because of their efficiency and effectiveness in the 
computer science world. I feel that if I were to implement these pathfinding/search algorithms, I 
would be able to achieve that level of understanding that I strive for. Further, the realm of graphs 
is very interesting to me just because I’ve never really worked with it before, and I enjoy learning 
and implementing things that are new to me, especially in computer science. Moreover, these 
algorithms are pretty important for technical/coding interview questions so it would give me an edge 
in landing a job/internship if I learned these algorithms and was proficient with them.

By the end of Week 1, I will have finished creating the Cinder layout with the squares and buttons 
(which allow the user to check and run different algorithms and allow the user to draw on the 
squares, similar to the Naive Bayes application) and will start working on the implementing the 
pathfinding/search algorithms. By the end of Week 2, I will have implemented the pathfinding/search 
algorithms and linked it with the display which will show the specific algorithm’s path and start 
working on testing the functionality of my algorithm I’ve implemented. By the end of Week 3, I will 
have tested the algorithms I designed in Week 2 and start documenting my code. If I have extra time 
in Week 3, I will start implementing the extra features of my program. 




